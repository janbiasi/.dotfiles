{
    "If Error (Inline)": {
        "prefix": "iferrinline",
        "description": "Handle a generic error inline",
        "body": [
            "if err := $1; err != nil {",
            "\t$2",
            "}"
        ]
    },
    "Struct with New function": {
        "prefix": "structwithnew",
        "description": "Create a struct with an instanciator (both public)",
        "body": [
            "type ${1:MyStruct} struct {",
            "\t$0",
            "}",
            "",
            "// Create a new instance of [${1:MyStruct}]",
            "func New${1:MyStruct}() *${1:MyStruct} {",
            "\treturn &${1:MyStruct}{}",
            "}"
        ]
    },
    "Struct with functional options": {
        "prefix": "structfuncopt",
        "description": "Create a struct with a functional options pattern for configuration",
        "body": [
            "// Functional option declaration for [${1:Struct}Opts]",
            "type ${1:Struct}OptFunc func(*${1:Struct}Opts)",
            "",
            "// Option shape declaration for [${1:Struct}]",
            "type ${1:Struct}Opts struct {",
            "\t${2:// add options here}",
            "}",
            "",
            "// Default option set for [${1:Struct}]",
            "func default${1:Struct}Opts() ${1:Struct}Opts {",
            "\treturn ${1:Struct}Opts{",
            "\t\t${3:// add default option values here}",
            "\t}",
            "}",
            "",
            "type ${1:Struct} struct {",
            "\t${1:Struct}Opts",
            "}",
            "",
            "// Create a new instance of [${1:Struct}] with functional options following [${1:Struct}OptFunc]",
            "func New${1:Struct}(opts ...${1:Struct}OptFunc) *${1:Struct} {",
            "\to := default${1:Struct}Opts()",
            "\tfor _, fn := range opts {",
            "\t\tfn(&o)",
            "\t}",
            "",
            "\treturn &${1:Struct}{",
                "\t\t${1:Struct}Opts: o,",
            "\t}",
            "}",
        ]
    },
    "Singleton (Thread Safe)": {
        "prefix": "singletonts",
        "description": "Create a thread safe singleton",
        "body": [
            "type ${1:Singleton} struct {",
            "\t${2:// options}",
            "}",
            "",
            "var (",
            "\tinstance *${1:Singleton}",
            "\tonce     sync.Once",
            ")",
            "",
            "func GetInstance() *${1:Singleton} {",
            "\tonce.Do(func() {",
            "\t\tinstance = &${1:Singleton}{",
            "\t\t\t${3:// options}",
            "}",
            "\t})",
            "",
            "\treturn instance",
            "}",
        ]
    },
    "Riverqueue Worker Declaration": {
        "prefix": "riverw",
        "description": "Create a new riverqueue worker",
        "body": [
            "type ${1:Worker}Args struct {",
            "\t// define arguments",
            "}",
            "",
            "func (${1:Worker}Args) Kind() string {",
            "\treturn \"${1/(\\w+)?[-_\\s]+(\\w+)/${1:/downcase}_${2:/downcase}/g}\"",
            "}",
            "",
            "// InsertOpts returns custom insert options that every job of this type will",
            "// inherit, including unique options.",
            "// func (${1:Worker}Args) InsertOpts() river.InsertOpts {",
            "// \treturn river.InsertOpts{",
            "// \t\tMaxAttempts: 1,",
            "// \t\tUniqueOpts: river.UniqueOpts{",
            "// \t\t\tByArgs:   true,",
            "// \t\t\tByPeriod: 24 * time.Hour,",
            "// \t\t},",
            "// \t}",
            "// }",
            "",
            "type ${1:Worker}Worker struct {",
            "\t// An embedded WorkerDefaults sets up default methods to fulfill the rest of the Worker interface",
            "\triver.WorkerDefaults[${1:Worker}Args]",
            "}",
            "",
            "func (w *${1:Worker}Worker) Work(ctx context.Context, job *river.Job[${1:Worker}Args]) error {",
            "\tsort.Strings(job.Args.Strings)",
            "\tfmt.Printf(\"${1:Worker}: %+v\", job.Args)",
            "\treturn nil",
            "}",
            "",
            "// Set custom timeout for this job",
            "// func (w *${1:Worker}Worker) Timeout(job *river.Job[${1:Worker}Args]) time.Duration {",
            "// \treturn 30 * time.Second",
            "// }",
            "",
            "// Set a custom deferred next retry time",
            "// func (w *${1:Worker}Worker) NextRetry(job *river.Job[${1:Worker}Args]) time.Time {",
            "// \treturn time.Now().Add(10*time.Second)",
            "// }",

        ]
    }
}