---
description: Manual context compression - summarize state, preserve decisions, generate resume prompt
---

Compress context mid-session. Use when context is getting long or before a complex pivot.

## Usage

```
/checkpoint                    # Generate compressed summary
/checkpoint --save-decisions   # Also file key decisions as beads
/checkpoint --to-file          # Write summary to .checkpoint.md in cwd
```

## Step 1: Gather Session State

Run these in parallel:

```bash
# Files changed this session
git status --short

# Uncommitted diff stats
git diff --stat

# Recent commits (this session)
git log --oneline -10

# Beads in progress
bd list --status in_progress --json

# Recently closed beads
bd list --status closed --json | jq -r '.[:5] | .[] | "\(.id): \(.title)"'
```

## Step 2: Analyze Session

Review the conversation history to identify:

- **Original Goal:** What was the user's initial request?
- **Accomplished:** What's been completed?
- **Remaining:** What's still left to do?
- **Key Decisions:** Architectural/design choices and WHY they were made
- **Patterns Discovered:** Any insights about the codebase
- **Blockers:** Open questions or issues

## Step 3: Generate Checkpoint

Output in this format:

```markdown
## Checkpoint: [YYYY-MM-DD HH:MM]

### Goal

[Original task/request - one clear sentence]

### Accomplished

- [Completed item with brief context]
- [Completed item with brief context]

### Remaining

- [Pending item]
- [Pending item]

### Key Decisions

| Decision          | Reasoning           |
| ----------------- | ------------------- |
| [What we decided] | [Why we decided it] |

### Patterns Discovered

- [Codebase insight or pattern worth remembering]

### Files Changed

| File            | Change Type              |
| --------------- | ------------------------ |
| path/to/file.ts | modified/created/deleted |

### Active Beads

| ID     | Title | Status      |
| ------ | ----- | ----------- |
| bd-xxx | Title | in_progress |

### Resume Prompt

---

Continue working on [goal].

Context:

- [Key context point 1]
- [Key context point 2]

Current state:

- [Where we left off]
- [What's loaded/ready]

Next steps:

1. [Immediate next action]
2. [Following action]

Key decisions already made:

- [Decision 1]
- [Decision 2]

---
```

## Step 4: Handle Flags

### If `--save-decisions`:

For each key decision identified, create a bead:

```bash
# Create decision beads
bd create "Decision: [brief title]" -t chore --json

# Add description with full reasoning
bd update $NEW_ID -d "## Decision\n[What]\n\n## Reasoning\n[Why]\n\n## Context\n[When/where this applies]"
```

Link decisions to current work if there's an active bead.

### If `--to-file`:

Write the checkpoint to `.checkpoint.md` in the current working directory:

```bash
# The checkpoint output goes to this file
# Include a header with generation info
```

File should start with:

```markdown
<!-- Generated by /checkpoint at [timestamp] -->
<!-- To resume: paste the Resume Prompt section into a new session -->
```

## Step 5: Compression Confirmation

After generating, confirm:

```markdown
**Checkpoint created.**

- Session compressed to ~[X] tokens (estimated)
- [N] key decisions captured
- [N] files tracked
- [N] beads active

To continue with fresh context, copy the **Resume Prompt** section.
```

## Tips

- Run `/checkpoint` before switching to a complex subtask
- Use `--save-decisions` for architectural choices worth preserving
- Use `--to-file` when handing off to another human or agent
- The Resume Prompt should be **self-contained** - assume zero prior context
